---
title: "Untitled"
output: html_document
date: "2025-04-03"
---

Load libraries
```{r setup, include=FALSE}
library(terra)
library(here)
library(dplyr)
library(sf)
library(mapview)
library(igraph)
library(landscapemetrics)
```

Read in data
```{r}
ppr <- st_read(here("data", "boundaries", "PPJV")) %>% st_transform(4326)
plots <- st_read(here("data", "allPlots")) 

# folder path to classifiedImage_May22
folder_path <- here("data/gee_exports/predicted_rasters/classifiedImage22_bal")
dataset_value <- "2022"

# get filenames of all 32 tif tiles
tif_files <- list.files(path = folder_path, pattern = "\\.tif$", full.names = TRUE)

# read each tif into a list of raster objects
raster_list <- lapply(tif_files, function(file){
  print(file)
  r <- rast(file) 
  return(r)
})
```

Convert raster to patch polygons (8-neighbor)
```{r}
r <- raster_list[[6]]

# crop down, for developing
#bbox <- ext(-98.8, -98.7, 48.3, 48.4)
#bbox <- ext(r)/8
#r <- crop(r, bbox) 

# reproject to UTM 14N
r <- r %>% project("EPSG:32614", res=10)

##################################
# Convert raster to patch polygons

# convert to binary prediction
r <- as.numeric(r >= 0.6) 

# Set NA values to 0 to avoid issues
r[is.na(r)] <- 0

# Identify connected components (wet areas) using clump()
r_patches <- patches(r, directions=8, zeroAsNA=T) 

# convert to sf polygons
sf_patches <- as.polygons(r_patches) %>% st_as_sf()
```

Add cluster id (a network where ponds are connected up to X meters)
```{r}
# get distance threshold
threshold <- units::set_units(450, "m") 

# get pond centroids - ILL PROBABLY WANNA USE EDGES INSTEAD OF CENTROIDS, AT SOME POINT
centroids <- sf::st_centroid(sf_patches)
dist_matrix <- sf::st_distance(centroids)

# drop points futher than threshold distance
adj_matrix <- dist_matrix <= threshold

# Set diagonal to FALSE to avoid self-connections
# diag(adj_matrix) <- FALSE

# Create graph from adjacency matrix
graph <- igraph::graph_from_adjacency_matrix(adj_matrix, mode = "undirected", diag = FALSE)

# Get connected components (clusters)
clusters <- igraph::components(graph)

# Each patch gets a cluster ID
sf_patches$cluster_id <- clusters$membership

# visualize
sf_patches %>% 
  group_by(cluster_id) %>% 
  filter(n() > 4) %>% 
  mapview(zcol="cluster_id")
```

Calcluate landscape metrics within each cluster
```{r}
cellarea <- 100

# Get the unique cluster IDs
complexes <- sf_patches %>% 
  st_drop_geometry() %>% 
  group_by(cluster_id) %>% 
  filter(n() > 4) %>% 
  pull(cluster_id) %>% 
  unique()

# Initialize an empty data frame to store the metrics for each cluster
complex_metrics_df <- data.frame(
  cluster_id = integer(),
  pond_density = numeric(),
  mean_pond_size = numeric(),
  sd_pond_size = numeric(),
  cv_pond_size = numeric(),
  mean_cai = numeric(),
  sd_cai = numeric(),
  cv_cai = numeric(),
  mean_para = numeric(),
  sd_para = numeric(),
  cv_para = numeric(),
  mean_shape = numeric(),
  sd_shape = numeric(),
  cv_shape = numeric(),
  inundated_area = numeric(),
  raster_area = numeric(),
  stringsAsFactors = FALSE
)

# Loop through each cluster and calculate the metrics
for (i in complexes) {
  
  # limit to cluster
  sf_cluster <- sf_patches %>% filter(cluster_id == i)
  
  # crop to cluster
  cluster_bbox <- st_bbox(sf_cluster) %>% ext()
  r_crop <- crop(r, cluster_bbox)
  
  # back to raster
  r_cluster <- rasterize(sf_cluster, r_crop, fun = "min") 
  
  # Calculate landscape metrics for the masked raster (you can choose different metrics)
  pond_density <- lsm_c_pd(r_cluster)$value        # patch density; # number of ponds per km2 (eg 44)
  mean_pond_size <- lsm_c_area_mn(r_cluster)$value  # average pond size (eg 2.25 ha)
  sd_pond_size <- lsm_c_area_sd(r_cluster)$value    # sd pond size (eg 9.15 ha)
  cv_pond_size <- lsm_c_area_cv(r_cluster)$value    # cv pond size (eg 24777)
  mean_cai <- lsm_c_cai_mn(r_cluster)$value        # mean core area index; core area / patch area (eg 40)
  sd_cai <- lsm_c_cai_sd(r_cluster)$value          # sd core area index (eg 29)
  cv_cai <- lsm_c_cai_cv(r_cluster)$value          # cv core area index (eg 73)
  mean_para <- lsm_c_para_mn(r_cluster)$value      # mean perimeter:area (eg 0.12)
  sd_para <- lsm_c_para_sd(r_cluster)$value        # sd perimeter:area (eg 0.10)
  cv_para <- lsm_c_para_cv(r_cluster)$value        # cv perimeter:area (eg 84)
  mean_shape <- lsm_c_shape_mn(r_cluster)$value    # mean perimeter:sqrt(area) (eg 1.4)
  sd_shape <- lsm_c_shape_sd(r_cluster)$value      # sd perimeter:sqrt(area) (eg 0.61)
  cv_shape <- lsm_c_shape_cv(r_cluster)$value      # cv perimeter:sqrt(area) (eg 42)
 
  inundated_area <- sum(r_cluster[], na.rm = TRUE) * cellarea
  raster_area <- (ext(r_cluster)[2] - ext(r_cluster)[1]) * (ext(r_cluster)[4] - ext(r_cluster)[3])
  
 # Store the metrics for the current cluster in the data frame
  complex_metrics_df <- complex_metrics_df %>%
    add_row(
      cluster_id = i,
      pond_density = pond_density,
      mean_pond_size = mean_pond_size,
      sd_pond_size = sd_pond_size,
      cv_pond_size = cv_pond_size,
      mean_cai = mean_cai,
      sd_cai = sd_cai,
      cv_cai = cv_cai,
      mean_para = mean_para,
      sd_para = sd_para,
      cv_para = cv_para,
      mean_shape = mean_shape,
      sd_shape = sd_shape,
      cv_shape = cv_shape,
      inundated_area = inundated_area,
      raster_area = raster_area
    )
}
```
